#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "graph.h"
#include "minheap.h"
#include "math.h"

#define NODE_UNDEF -1


void printMatrix(int **matrix, int n, int m) {
    int i, j;
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            printf("| %d ", matrix[i][j]);
            if (j == m - 1) {
                printf("\n");
            }
        }
    }
}

static int getIndex(int i, int j, int nCol) {
    return i * nCol + j;
}

/* crea il metodo contrario a getIndex */
static void getIJ(int index, int nCol, int *i, int *j) {
    *i = index / nCol;
    *j = index % nCol;
}

/* funzione che legge l'array dei predecessori e ritorna il cammino dal nodo 'src' al nodo 'dst'*/
static int get_path(const int *p, int src, int dst, int *path)
{
    int i = 0;
    if (dst != NODE_UNDEF) {
        i = get_path(p, src, p[dst], path);
        path[i] = dst;
        i++;
    }
    return i;
}


static void dijkstra( const Graph *g, int s, double *d, int *p)
{
    int i, u;
    Edge *adj;
    MinHeap *h = minheap_create(graph_n_nodes(g));
    for (i = 0; i < graph_n_nodes(g); i++) {
        d[i] = HUGE_VAL;
        p[i] = NODE_UNDEF;
    }
    for (i = 0; i < graph_n_nodes(g); i++) {
        minheap_insert(h, i, d[i]);
    }
    d[s] = 0;
    
    while (!minheap_is_empty(h))
    {
        u = minheap_delete_min(h);
        adj = graph_adj(g, u);
        while (adj != NULL)
        {
            if (d[adj->dst] > (d[u] + adj->weight)) {
                d[adj->dst] = (d[u] + adj->weight);
                p[adj->dst] = u;
                minheap_change_prio(h, adj->dst, d[adj->dst]);
            }
            adj = adj->next;
        }
        
    }
}

/* stampa tutti i percorsi da src a dst */
static void print_all_paths_dijkstra(const Graph *g, int src, int dst)
{
    int i, j, k;
    int *path;
    double *d; 
    int *p;
    int n = graph_n_nodes(g);
    d = (double*)malloc(n * sizeof(double));
    p = (int*)malloc(n * sizeof(int));
    dijkstra(g, src, d, p);
    path = (int*)malloc(n * sizeof(int));
    k = get_path(p, src, dst, path);
    for (i = 0; i < k; i++) {
        printf("%d ", path[i]);
    }
    printf("\n");
}

int main(int argc, char const *argv[])
{
    Graph *g;
    int n, m;
    int i, j, k, i2, j2;
    char cval;
    int val;
    int **matrix;
    double *d; 
    int **p;
    int *path;
    int w = 0;
    FILE *filein = stdin;
    if (argc < 2) {
        fprintf(stderr, "Usage: %s filename [src [dst]]\n", argv[0]);
        return EXIT_FAILURE;
    }

    if (strcmp(argv[1], "-") != 0) {
        filein = fopen(argv[1], "r");
        if (filein == NULL) {
            fprintf(stderr, "Can not open %s\n", argv[1]);
            return EXIT_FAILURE;
        }
    }

    fscanf(filein, "%d %d", &n, &m);
    
    g = (Graph *)malloc(sizeof(Graph));
    g = graph_create(n * m, GRAPH_UNDIRECTED);

    matrix = (int **)malloc(n * sizeof(int *));
    for (i = 0; i < n; i++) {
        matrix[i] = (int *)malloc(m * sizeof(int));
    }
    
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            fscanf(filein, "%c", &cval);
            if (cval == '\n') {
                fscanf(filein, "%c", &cval);
            }
            val = atoi(&cval);
            matrix[i][j] = val;
        }
    }

    //printMatrix(matrix, n, m);
    printf("\n");

    /* set the wet cells -1 */
    k = 0;
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            val = matrix[i][j];
            if (val > 0) {
                for (k = 1; k <= val; k++) {
                    if (j + k >= m) {
                        break;
                    } else if (matrix[i][j+k] == 0) {
                        matrix[i][j+k] = -1;        
                    }
                }
            } else {
                matrix[i][j] = val;
            }
        }
    }

    //printMatrix(matrix, n, m);
    printf("\n");

    /* set the edges */
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            val = matrix[i][j];
            
            if (val == 0 || val == -1) {
                if (i == n - 1 && j == m - 1) {
                    break;
                } else if (j == m - 1) {
                    if (matrix[i+1][j] == 0) {
                        graph_add_edge(g, getIndex(i, j, m), getIndex(i+1, j, m), 1);
                    } else if (matrix[i+1][j] == -1) {
                        graph_add_edge(g, getIndex(i, j, m), getIndex(i+1, j, m), 1);
                    }
                } else if (i == n - 1) {
                    if (matrix[i][j+1] == 0) {
                        graph_add_edge(g, getIndex(i, j, m), getIndex(i, j+1, m), 1);
                    } else if (matrix[i][j+1] == -1) {
                        graph_add_edge(g, getIndex(i, j, m), getIndex(i, j+1, m), 1);
                    }
                } else {
                    if (matrix[i][j+1] == 0) {
                        graph_add_edge(g, getIndex(i, j, m), getIndex(i, j+1, m), 1);
                    } else if (matrix[i][j+1] == -1) {
                        graph_add_edge(g, getIndex(i, j, m), getIndex(i, j+1, m), 1);
                    }
                    if (matrix[i+1][j] == 0) {
                        graph_add_edge(g, getIndex(i, j, m), getIndex(i+1, j, m), 1);
                    } else if (matrix[i+1][j] == -1) {
                        graph_add_edge(g, getIndex(i, j, m), getIndex(i+1, j, m), 1);
                    }
                }
            }
        }
        
    }
    
    /* graph_print(g); */
    d = (double*)malloc((n*m) * sizeof(double));
    p = (int**)malloc((n*m) * sizeof(int*));
    for (i = 0; i < n*m; i++) {
        p[i] = (int*)malloc((n*m) * sizeof(int));
    }

    dijkstra(g, 0, d, p);
    
    path = (int*)malloc((n*m) * sizeof(int));
    k = get_path(p, 0, (n*m) - 1, path);

    for (i = 0; i < k; i++) {
        getIJ(path[i], m, &i2, &j2);
        if (matrix[i2][j2] == -1) {
            w++;
        }  
    }
    

    printf("%d %d\n", k, k-w);
    for (i = 0; i < k; i++) {
        if (path[i] == path[i+1] - 1) {
            printf("E");
        } else if (path[i] == path[i+1] - m) {
            printf("S");
        } else if (path[i] == path[i+1] + 1) {
            printf("W");
        } else if (path[i] == path[i+1] + m) {
            printf("N");
        }
        
    }
    


    return 0;
}
