Ci sono ancora problemi da risolvere.

Dato che c'è tempo in abbondanza prima del prossimo appello, invito a dedicare
tutto il tempo necessario a risolvere i vari punti con calma. In particolare, si
evitino consegne frettolose.

Il problema della gestione della memoria non è stato risolto:

==6217== Memcheck, a memory error detector
==6217== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==6217== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==6217== Command: ./0000970373.exe /home/moreno/Downloads/input/test1.in
==6217==
==6217== Invalid read of size 4
==6217==    at 0x10B2A0: main (0000970373.c:702)
==6217==  Address 0x4a67ac8 is 0 bytes after a block of size 40 alloc'd
==6217==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==6217==    by 0x10AB84: fillMatrix (0000970373.c:609)
==6217==    by 0x10B217: main (0000970373.c:693)
==6217==
==6217== Invalid write of size 4
==6217==    at 0x10B2DE: main (0000970373.c:703)
==6217==  Address 0x4a67ac8 is 0 bytes after a block of size 40 alloc'd
==6217==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==6217==    by 0x10AB84: fillMatrix (0000970373.c:609)
==6217==    by 0x10B217: main (0000970373.c:693)
==6217==
31 22
==6217== Conditional jump or move depends on uninitialised value(s)
==6217==    at 0x10AA14: printPath (0000970373.c:588)
==6217==    by 0x10B3F8: main (0000970373.c:728)
==6217==
==6217== Conditional jump or move depends on uninitialised value(s)
==6217==    at 0x10AA5A: printPath (0000970373.c:590)
==6217==    by 0x10B3F8: main (0000970373.c:728)
==6217==
==6217== Conditional jump or move depends on uninitialised value(s)
==6217==    at 0x10AAA1: printPath (0000970373.c:592)
==6217==    by 0x10B3F8: main (0000970373.c:728)
==6217==
==6217== Conditional jump or move depends on uninitialised value(s)
==6217==    at 0x10AAE7: printPath (0000970373.c:594)
==6217==    by 0x10B3F8: main (0000970373.c:728)
==6217==
SSSSSEEEEENNWWNNEEEESESSSSSSSE==6217==
==6217== HEAP SUMMARY:
==6217==     in use at exit: 0 bytes in 0 blocks
==6217==   total heap usage: 144 allocs, 144 frees, 14,216 bytes allocated
==6217==
==6217== All heap blocks were freed -- no leaks are possible
==6217==
==6217== Use --track-origins=yes to see where uninitialised values come from
==6217== For lists of detected and suppressed errors, rerun with: -s
==6217== ERROR SUMMARY: 66 errors from 6 contexts (suppressed: 0 from 0)

La soluzione implementata per rimuovere il "break", come avevo richiesto, non è
corretta. Infatti, come spiegato a lezione (e come visto nel corso di
programmazione) la condizione:

if (matrix[i][j+k] == 0 && j + k <= m) {

viene valutata da sinistra verso destra; di conseguenza, se j+k>m (il che
costituirebbe un accesso non valido alla memoria), viene comunque letto il
contenuto di matrix[i][j+k] causando un accesso out-of-bound.

Inoltre, se l'idea di quel ciclo è: "itera da k=1 fino a k<=val, purché si abbia
anche j+k <=m", è possibile includere tale condizione direttamente nel ciclo
"for" anziché dover usare un "if" all'interno.

Non sono sicuro poi che la condizione "j+k<=m" sia corretta: invito a
controllare le dimensioni della matrice "matrix[][]" e controllare che tutti gli
indici usati siano validi.

Ne approfitto anche per segnalare che la funzione fillGraph() presenta molta
ridondanza e un livello di annidamento dei costrutti eccessivo (for -> for -> if
-> else -> if). A causa di questo, la logica su cui si basa la funzione non
risulta molto chiara. Invito a fattorizzare la funzione, ed eventualmente ad
aggiungere dei commenti significativi per aiutare chi legge a capire cosa si fa.

A proposito di commenti: sono stati copia&incollati quelli presenti nel codice
fornito in laboratorio. Ciò non è un problema, dato che era espressamente
consentito dalle specifiche, ma sarebbe stato apprezzabile uno sforzo almeno per
ripulirli dalle parti che servivano solo per l'esercitazione e non sono più
significative in un programma già fatto e finito.

